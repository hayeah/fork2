# Vibe: A Simple Tool for Building Complex Prompts

- [Install](#install)
- [Pattern Matching Tutorial](#pattern-matching-tutorial)
  - [Basic patterns](#basic-patterns)
  - [Operators](#operators)
  - [Worked Examples](#worked-examples)
- [Prompt Templates](#prompt-templates)
  - [How rendering works](#how-rendering-works)
  - [Example Chat Log](#example-chat-log)
- [Layout as Wrapper](#layout-as-wrapper)
- [Prompt Lookup Paths](#prompt-lookup-paths)
- [Builtin Prompts](#builtin-prompts)

`vibe` is a CLI that helps you build complex prompts by selecting repo files, and rendering reuseable prompt templates.

- **File selection** – match any subset of your repo with a mini pattern language (e.g. `.go|!_test.go`). Inspired by tools like [repomix](https://github.com/yamadashy/repomix) and [Repo Prompt](https://repoprompt.com/).
- **Composable templates** – layouts and partials let you wrap prefixes/suffixes, inject roles or tool specs, and branch on env/CLI vars. Think a blog engine like Hugo/Jekyll, but for prompts.
- **Shareable workflows** – keep prompt recipes in‑repo so the whole team can reuse and version them.

## Install

```bash
go install github.com/hayeah/fork2/cmd/vibe@latest
```

## Pattern Matching Tutorial

vibe uses a tiny pattern language to tell which paths you want and which you don’t.

- Basic patterns
  - Fuzzy matching: `.go` or `util`
  - Regex: `/test\.go$`
  - Exact matching: `=./cmd/main.go`
  - Whole directory: `=./util`, to include all files in that directory
- **Operators** to combine the basic patterns (order of precedence):
  - `!` = **NOT** (exclude matches)
  - `|` = **AND** (all sub‑patterns must match)
  - `;` = **OR** (whichever pattern matches)

Examples:

- `.go`
  Select every file whose path **contains** `.go`.

- `!.md`
  Exclude markdown files.

- `.go|util`
  Select `.go` files that also matches `util`

- `.go|!_test.go`
  Select `.go` files **but not** their tests.

- `.go;.md`
  All Go files **or** plus all `.md` files.

- `.go|!_test.go;.md`
  All non test `.go` files, plus `.md` files

#### Worked Examples

Show me every Go file in the repo

```bash
vibe ask --select .go
```

Study utilities only

```bash
vibe ask --select '.go|util'
# Meaning: “choose files that end in .go AND include ‘util’
```

Show me every Go file in the repo, but leave out any test files

```bash
vibe ask --select '.go|!_test.go'
# similar to using inverted grep to filter:
# git ls-files '*.go' | grep -v '_test.go'
```

Grab Markdown plus Go code

```bash
# 4.
vibe ask --select '.go;.md'
```

Let's combine everything. Select all go files that are not test files, plus all markdown files:

```bash
vibe ask --select '.go|!_test.go;.md'
```

Instead of using `;`, you could also put multiple patterns on different lines:

```bash
vibe ask --select '.go
!_test.go;.md'
```

## Prompt Templates

Prompt templates turn vibe into a tiny static‑site generator—except the “pages” it builds are prompts instead of HTML. Each template is just a text or markdown file that contains two distinct parts:

Front‑matter (TOML) – establishes how the template is rendered. The block is enclosed in a fenced code block at the very start of the file.

````md
```
layout = "files"
```

Give me an overview and walkthrough of the above code.
````

The template body is normal text/markdown that may use Go text/template syntax
`{{ ... }}` to reference data that vibe makes available at render time.

### How rendering works

When you run

```bash
vibe ask explain.md --select '.go|!_test.go'
```

vibe:

1. **Collects source files** that match the pattern.
2. **Builds a data object** containing things like:
   - `.RepoDirectoryTree` – a pretty `tree` ‑style listing
   - `.FileMap` – a collapsed or full listing of the selected files
   - `.RepoPrompts` – any repo‑wide instructions (`*.prompt.md` in the root)
   - Environment variables (`.Env`)
   - CLI variables (`--var key=value` → `.Vars.key`)
3. **Parses _explain.md_** as a Go template, plugging the data into the placeholders.
4. **Applies the chosen layout** (see next section) to wrap the result.

Because it is plain Go templating, you can:

- **Branch** on values:
  ```md
  {{ if eq .Env.CI "true" -}}
  _Running inside CI – keep the answer short_
  {{- end }}
  ```

### Example chat log

1. **Repository in focus** – [LibraDB](https://github.com/amit-davidson/LibraDB), a minimalist key‑value store implemented in roughly **1 k LOC of Go**.
2. **Prompt generated by `vibe ask`** – see the exact prompt here: <https://gist.github.com/hayeah/82043a1ef35a4cd0b09c58a0a351f2fe>.
3. **ChatGPT o3 response** – the model’s full answer to that prompt: <https://chatgpt.com/share/6807af90-8208-800e-baac-2b4bc3b4b461>.
4. **Reference for comparison** – the original LibraDB deep‑dive blog post: <https://medium.com/better-programming/build-a-nosql-database-from-the-scratch-in-1000-lines-of-code-8ed1c15ed924>.

## Layout as Wrapper

Where templates define **what** you want to say, **layouts** define **how** you surround that content. Think of a layout as the `<html><head><body>` of a prompt.

A layout is itself a Go template that _must_ contain a single placeholder named `.Content` where the inner template will be injected:

```md
<!-- layouts/files.md -->

Use the background information below to help you accomplish the task.

- **Repo Directory Tree**
- **Selected Files**

## Repo Directory Tree

{{ .RepoDirectoryTree }}

## Selected Files

{{ .FileMap }}

{{- if .RepoPrompts }}

## Repo‑Wide Instructions

{{ .RepoPrompts }}
{{- end }}

---

## User Task

{{ .Content }}

<!-- Optionally finish with reminders, tools spec, etc. -->
```

Anything outside `.Content` is a **wrapper** that you can standardise across an organisation. Typical uses:

- **Role instructions** up top (“You are an expert Go reviewer …”).
- **Context** in the middle (directory tree, diff stats, benchmarks).
- **Safety rails** at the bottom (response format, length limit, tool usage).

## Template Data

You can pass key-value pairs to your templates using the `-d/--data` flag. These values are accessible in your templates via the `.Data` map:

```bash
# Pass individual key-value pairs
vibe ask -d model=gpt4 -d format=json myPrompt.md

# Or use URL-style query parameters
vibe ask -d "model=gpt4&format=json" myPrompt.md
```

In your templates, access these values using the `.Data` map:

```md
<!-- Use specific instructions based on model -->
{{- if eq .Data.model "gpt4" }}
You are using GPT-4. Please provide a detailed analysis.
{{- else }}
Please provide a concise summary.
{{- end }}

<!-- Format output based on user preference -->
{{- if eq .Data.format "json" }}
Return your response in JSON format.
{{- end }}
```

This feature is useful for creating templates that can adapt based on runtime parameters without modifying the template itself.

## Prompt Lookup Paths

when finding a template to render, vibe will look through the following paths in order

- current repo
- VIBE_PROMPTS
- ~/.vibe
- builtin system prompts

## Builtin Prompts

The `explain.md` example is already built-in as a system prompt. You can invoke it:

```bash
vibe ask explain --select '.go'
```
